package main

import (
	"fmt"
	"path"

	"github.com/gitpod-io/flex-api-go/tools/logfields"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	logfieldsImport = protogen.GoImportPath("github.com/gitpod-io/flex-api-go/tools/logfields")

	EntryRef      = logfieldsImport.Ident("Entry")
	CollectionRef = logfieldsImport.Ident("Collection")
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			// Skip the proto used for our extension definition
			if *f.Proto.Name == "gitpod/tools/v1/logfields.proto" {
				continue
			}

			if !f.Generate {
				continue
			}

			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	var (
		filename = path.Join(
			path.Dir(file.GeneratedFilenamePrefix),
			fmt.Sprintf("%s.fields.go", path.Base(file.GeneratedFilenamePrefix)))
		importPath = file.GoImportPath
	)

	g := gen.NewGeneratedFile(filename, importPath)

	g.P("// Code generated by gitpod-log-fields. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.Import(logfieldsImport)
	g.P()

	for _, message := range file.Messages {

		g.P(fmt.Sprintf("func (x *%s) LogFields() %s {",
			message.GoIdent.GoName,
			g.QualifiedGoIdent(CollectionRef)),
		)

		fields := messageLogFields(message)

		if len(fields) == 0 {
			g.P("    return nil")
		} else {
			g.P("   if x == nil {")
			g.P("       return nil")
			g.P("   }")
			g.P("")
			g.P("	var fields logfields.Collection")

			for _, field := range fields {
				g.P(field)
			}

			g.P("    return fields")
		}

		g.P("}")
		g.P()

	}
}

func messageLogFields(message *protogen.Message) []string {
	var fields []string
	for _, field := range message.Fields {

		if field.Desc.Cardinality() == protoreflect.Repeated {
			// We do not populate repeated fields
			continue
		}

		switch field.Desc.Kind() {
		case protoreflect.StringKind:
			ext := proto.GetExtension(field.Desc.Options(), logfields.E_Logfield)

			asExt, ok := ext.(*logfields.LogField)
			if !ok || asExt == nil {
				continue
			}

			fields = append(fields, "fields.Add(&logfields.Entry{Name: \""+asExt.Name+"\", Value: x."+field.GoName+"})")

		case protoreflect.MessageKind:
			// Nested message, we extract from the nested message recursively
			fields = append(fields, "fields.Add(logfields.Extract(x.Get"+field.GoName+"())...)")
		}

	}
	return fields
}
